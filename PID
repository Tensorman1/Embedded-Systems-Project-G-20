#include "mbed.h"
#include "QEI.h"

QEI encoderR(PB_1, PC_4, NC, 256);
QEI encoderL(PA_2, PA_3, NC, 256);

class PIDController {
private:
    const double Kd = 0.05; // Derivative gain
    const double Ki = 0.01; // Integral gain
    const double Kp = 0.1;  // Proportional gain
    float integral = 0;     // Integral term

public:
    float calculatePID(float error, float prevError) {
        float proportional = Kp * error;
        float derivative = Kd * (error - prevError);
        integral += error * Ki;
        return proportional + integral + derivative;
    }
    float motor_speed(){
         unsigned long currentMillis = millis();
        if (currentMillis - previousMillis >= interval) {
            long pulses = myEnc.getPulses();
            long revolutions = myEnc.getRevolutions();
            
            // Calculate time elapsed since last calculation
            float deltaTime = (currentMillis - previousMillis) / 1000.0; // Convert to seconds
            
            // Calculate speed in revolutions per second (RPS)
            float speed_rps = (revolutions * 1.0) / deltaTime;
            
            // Convert speed to RPM (Revolutions per minute)
            float speed_rpm = speed_rps * 60;
            // Update previous millis for next calculation
            previousMillis = currentMillis;
        }
    }
};
// Get speed from the motors using the encoders and adjust according to the output generated by the PID calculation above

}

int main() {
    double prevError = 0;
    double integral = 0;

    // Main control loop
    while (true) {
        // Read sensor values

        
        double error = 0; // Placeholder for error calculation

        
        double pidOutput = calculatePID(error, previous_error, integral);

        
        adjustMotors(pidOutput);

        previous_error = error;        // Add delay or control loop rate control here
    }
    return 0;
}
